{"/home/travis/build/npmtest/node-npmtest-jsontool/test.js":"/* istanbul instrument in package npmtest_jsontool */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-jsontool/lib.npmtest_jsontool.js":"/* istanbul instrument in package npmtest_jsontool */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_jsontool = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_jsontool = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-jsontool/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-jsontool && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_jsontool */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_jsontool\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_jsontool.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_jsontool.rollup.js'] =\n            local.assetsDict['/assets.npmtest_jsontool.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_jsontool.__dirname + '/lib.npmtest_jsontool.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-jsontool/node_modules/jsontool/lib/jsontool.js":"#!/usr/bin/env node\n/**\n * Copyright (c) 2013 Trent Mick. All rights reserved.\n * Copyright (c) 2013 Joyent Inc. All rights reserved.\n *\n * json -- JSON love for your command line.\n *\n * See <https://github.com/trentm/json> and <https://trentm.com/json/>\n */\n\nvar VERSION = '7.0.2';\n\nvar p = console.warn;\nvar util = require('util');\nvar assert = require('assert');\nvar path = require('path');\nvar vm = require('vm');\nvar fs = require('fs');\nvar warn = console.warn;\nvar EventEmitter = require('events').EventEmitter;\n\n\n\n//--- exports for module usage\n\nexports.main = main;\nexports.getVersion = getVersion;\nexports.parseLookup = parseLookup;\n\n// As an exported API, these are still experimental:\nexports.lookupDatum = lookupDatum;\nexports.printDatum = printDatum; // DEPRECATED\n\n\n\n//---- globals and constants\n\n// Output modes.\nvar OM_JSONY = 1;\nvar OM_JSON = 2;\nvar OM_INSPECT = 3;\nvar OM_COMPACT = 4;\nvar OM_FROM_NAME = {\n    'jsony': OM_JSONY,\n    'json': OM_JSON,\n    'inspect': OM_INSPECT,\n    'compact': OM_COMPACT\n}\n\n\n\n//---- support functions\n\nfunction getVersion() {\n    return VERSION;\n}\n\n/**\n * Return a *shallow* copy of the given object.\n *\n * Only support objects that you get out of JSON, i.e. no functions.\n */\nfunction objCopy(obj) {\n    var copy;\n    if (Array.isArray(obj)) {\n        copy = obj.slice();\n    } else if (typeof (obj) === 'object') {\n        copy = {};\n        Object.keys(obj).forEach(function (k) {\n            copy[k] = obj[k];\n        });\n    } else {\n        copy = obj; // immutable type\n    }\n    return copy;\n}\n\nif (util.format) {\n    format = util.format;\n} else {\n    // From <https://github.com/joyent/node/blob/master/lib/util.js#L22>:\n    var formatRegExp = /%[sdj%]/g;\n\n    function format(f) {\n        if (typeof (f) !== 'string') {\n            var objects = [];\n            for (var i = 0; i < arguments.length; i++) {\n                objects.push(util.inspect(arguments[i]));\n            }\n            return objects.join(' ');\n        }\n        var i = 1;\n        var args = arguments;\n        var len = args.length;\n        var str = String(f).replace(formatRegExp, function (x) {\n            if (i >= len)\n              return x;\n            switch (x) {\n            case '%s':\n                return String(args[i++]);\n            case '%d':\n                return Number(args[i++]);\n            case '%j':\n                return JSON.stringify(args[i++]);\n            case '%%':\n                return '%';\n            default:\n                return x;\n            }\n        });\n        for (var x = args[i]; i < len; x = args[++i]) {\n            if (x === null || typeof (x) !== 'object') {\n                str += ' ' + x;\n            } else {\n                str += ' ' + util.inspect(x);\n            }\n        }\n        return str;\n    };\n}\n\n/**\n * Parse the given string into a JS string. Basically: handle escapes.\n */\nfunction _parseString(s) {\n    /* JSSTYLED */\n    var quoted = '\"' + s.replace(/\\\\\"/, '\"').replace('\"', '\\\\\"') + '\"';\n    return eval(quoted);\n}\n\n// json_parse.js (<https://github.com/douglascrockford/JSON-js>)\n/* BEGIN JSSTYLED */\n// START json_parse\nvar json_parse=function(){\"use strict\";var a,b,c={'\"':'\"',\"\\\\\":\"\\\\\",\"/\":\"/\",b:\"\\b\",f:\"\\f\",n:\"\\n\",r:\"\\r\",t:\"\\t\"},d,e=function(b){throw{name:\"SyntaxError\",message:b,at:a,text:d}},f=function(c){return c&&c!==b&&e(\"Expected '\"+c+\"' instead of '\"+b+\"'\"),b=d.charAt(a),a+=1,b},g=function(){var a,c=\"\";b===\"-\"&&(c=\"-\",f(\"-\"));while(b>=\"0\"&&b<=\"9\")c+=b,f();if(b===\".\"){c+=\".\";while(f()&&b>=\"0\"&&b<=\"9\")c+=b}if(b===\"e\"||b===\"E\"){c+=b,f();if(b===\"-\"||b===\"+\")c+=b,f();while(b>=\"0\"&&b<=\"9\")c+=b,f()}a=+c;if(!isFinite(a))e(\"Bad number\");else return a},h=function(){var a,d,g=\"\",h;if(b==='\"')while(f()){if(b==='\"')return f(),g;if(b===\"\\\\\"){f();if(b===\"u\"){h=0;for(d=0;d<4;d+=1){a=parseInt(f(),16);if(!isFinite(a))break;h=h*16+a}g+=String.fromCharCode(h)}else if(typeof c[b]==\"string\")g+=c[b];else break}else g+=b}e(\"Bad string\")},i=function(){while(b&&b<=\" \")f()},j=function(){switch(b){case\"t\":return f(\"t\"),f(\"r\"),f(\"u\"),f(\"e\"),!0;case\"f\":return f(\"f\"),f(\"a\"),f(\"l\"),f(\"s\"),f(\"e\"),!1;case\"n\":return f(\"n\"),f(\"u\"),f(\"l\"),f(\"l\"),null}e(\"Unexpected '\"+b+\"'\")},k,l=function(){var a=[];if(b===\"[\"){f(\"[\"),i();if(b===\"]\")return f(\"]\"),a;while(b){a.push(k()),i();if(b===\"]\")return f(\"]\"),a;f(\",\"),i()}}e(\"Bad array\")},m=function(){var a,c={};if(b===\"{\"){f(\"{\"),i();if(b===\"}\")return f(\"}\"),c;while(b){a=h(),i(),f(\":\"),Object.hasOwnProperty.call(c,a)&&e('Duplicate key \"'+a+'\"'),c[a]=k(),i();if(b===\"}\")return f(\"}\"),c;f(\",\"),i()}}e(\"Bad object\")};return k=function(){i();switch(b){case\"{\":return m();case\"[\":return l();case'\"':return h();case\"-\":return g();default:return b>=\"0\"&&b<=\"9\"?g():j()}},function(c,f){var g;return d=c,a=0,b=\" \",g=k(),i(),b&&e(\"Syntax error\"),typeof f==\"function\"?function h(a,b){var c,d,e=a[b];if(e&&typeof e==\"object\")for(c in e)Object.prototype.hasOwnProperty.call(e,c)&&(d=h(e,c),d!==undefined?e[c]=d:delete e[c]);return f.call(a,b,e)}({\"\":g},\"\"):g}}();\n// END json_parse\n/* END JSSTYLED */\n\nfunction printHelp() {\n    /* BEGIN JSSTYLED */\n    var w = console.log;\n    w('Usage:');\n    w('  <something generating JSON on stdout> | json [OPTIONS] [LOOKUPS...]');\n    w('  json -f FILE [OPTIONS] [LOOKUPS...]');\n    w('');\n    w('Pipe in your JSON for pretty-printing, JSON validation, filtering, ');\n    w('and modification. Supply one or more `LOOKUPS` to extract a ');\n    w('subset of the JSON. HTTP header blocks are skipped by default.');\n    w('Roughly in order of processing, features are:');\n    w('');\n    w('Grouping:');\n    w('  Use \"-g\" or \"--group\" to group adjacent objects, separated by');\n    w('  by no space or a by a newline, or adjacent arrays, separate by');\n    w('  by a newline. This can be helpful for, e.g.: ');\n    w('     $ cat *.json | json -g ... ');\n    w('  and similar.');\n    w('');\n    w('Execution:');\n    w('  Use the \"-E CODE\" option to execute JavaScript code on the input JSON.');\n    w('     $ echo \\'{\"name\":\"trent\",\"age\":38}\\' | json -E \\'this.age++\\'');\n    w('     {');\n    w('       \"name\": \"trent\",');\n    w('       \"age\": 39');\n    w('     }');\n    w('  If input is an array, this will automatically process each');\n    w('  item separately.');\n    w('');\n    w('Conditional filtering:');\n    w('  Use the \"-C CODE\" option to filter the input JSON.');\n    w('     $ echo \\'[{\"age\":38},{\"age\":4}]\\' | json -C \\'this.age>21\\'');\n    w('     [{\\'age\\':38}]');\n    w('  If input is an array, this will automatically process each');\n    w('  item separately. Note: \"CODE\" is JavaScript code.');\n    w('');\n    w('Lookups:');\n    w('  Use lookup arguments to extract particular values:');\n    w('     $ echo \\'{\"name\":\"trent\",\"age\":38}\\' | json name');\n    w('     trent');\n    w('');\n    w('  Use \"-a\" for *array processing* of lookups and *tabular output*:');\n    w('     $ echo \\'{\"name\":\"trent\",\"age\":38}\\' | json name age');\n    w('     trent');\n    w('     38');\n    w('     $ echo \\'[{\"name\":\"trent\",\"age\":38},');\n    w('               {\"name\":\"ewan\",\"age\":4}]\\' | json -a name age');\n    w('     trent 38');\n    w('     ewan 4');\n    w('');\n    w('In-place editing:');\n    w('  Use \"-I, --in-place\" to edit a file in place:');\n    w('     $ json -I -f config.json  # reformat');\n    w('     $ json -I -f config.json -c \\'this.logLevel=\"debug\"\\' # add field');\n    w('');\n    w('Pretty-printing:');\n    w('  Output is \"jsony\" by default: 2-space indented JSON, except a');\n    w('  single string value is printed without quotes.');\n    w('     $ echo \\'{\"name\": \"trent\", \"age\": 38}\\' | json');\n    w('     {');\n    w('       \"name\": \"trent\",');\n    w('       \"age\": 38');\n    w('     }');\n    w('     $ echo \\'{\"name\": \"trent\", \"age\": 38}\\' | json name');\n    w('     trent');\n    w('');\n    w(\"  Use '-j' or '-o json' for explicit JSON, '-o json-N' for N-space indent:\");\n    w('     $ echo \\'{\"name\": \"trent\", \"age\": 38}\\' | json -o json-0');\n    w('     {\"name\":\"trent\",\"age\":38}');\n    w('');\n    w('Options:');\n    w('  -h, --help    Print this help info and exit.');\n    w('  --version     Print version of this command and exit.');\n    w('  -q, --quiet   Don\"t warn if input isn\"t valid JSON.');\n    w('');\n    w('  -f FILE       Path to a file to process. If not given, then');\n    w('                stdin is used.');\n    w('  -I, --in-place  In-place edit of the file given with \"-f\".');\n    w('                Lookups are not allow with in-place editing');\n    w('                because it makes it too easy to lose content.');\n    w('');\n    w('  -H            Drop any HTTP header block (as from `curl -i ...`).');\n    w('  -g, --group   Group adjacent objects or arrays into an array.');\n    w('  --merge       Merge adjacent objects into one. Keys in last ');\n    w('                object win.');\n    w('  --deep-merge  Same as \"--merge\", but will recurse into objects ');\n    w('                under the same key in both.')\n    w('  -a, --array   Process input as an array of separate inputs');\n    w('                and output in tabular form.');\n    w('  -A            Process input as a single object, i.e. stop');\n    w('                \"-e\" and \"-c\" automatically processing each');\n    w('                item of an input array.');\n    w('  -d DELIM      Delimiter char for tabular output (default is \" \").');\n    w('  -D DELIM      Delimiter char between lookups (default is \".\"). E.g.:');\n    w('                  $ echo \\'{\"a.b\": {\"b\": 1}}\\' | json -D / a.b/b');\n    w('');\n    w('  -E CODE       Execute the given JavaScript code on the input. If input');\n    w('                is an array, then each item of the array is processed');\n    w('                separately (use \"-A\" to override).');\n    w('  -C CODE       Filter the input with JavaScript `CODE`. If `CODE`');\n    w('                returns false-y, then the item is filtered out. If');\n    w('                input is an array, then each item of the array is ');\n    w('                processed separately (use \"-A\" to override).');\n    w('  -e CODE, -c CODE');\n    w('                Similar to \"-E CODE\" and \"-C CODE\", respectively,');\n    w('                but potentially much slower. Deprecated. Remains ');\n    w('                for backward compat. See the full docs for details.');\n    w('');\n    w('  -k, --keys    Output the input object\\'s keys.');\n    w('  -n, --validate  Just validate the input (no processing or output).');\n    w('                Use with \"-q\" for silent validation (exit status).');\n    w('');\n    w('  -o, --output MODE   Specify an output mode. One of');\n    w('                  jsony (default): JSON with string quotes elided');\n    w('                  json: JSON output, 2-space indent');\n    w('                  json-N: JSON output, N-space indent, e.g. \"json-4\"');\n    w('                  inspect: node.js `util.inspect` output');\n    w('  -i            shortcut for `-o inspect`');\n    w('  -j            shortcut for `-o json`');\n    w('');\n    w('See <http://trentm.com/json> for more docs and ');\n    w('<https://github.com/trentm/json> for project details.');\n    /* END JSSTYLED */\n}\n\n\n/**\n * Parse the command-line options and arguments into an object.\n *\n *    {\n *      'args': [...]       // arguments\n *      'help': true,       // true if '-h' option given\n *       // etc.\n *    }\n *\n * @return {Object} The parsed options. `.args` is the argument list.\n * @throws {Error} If there is an error parsing argv.\n */\nfunction parseArgv(argv) {\n    var parsed = {\n        args: [],\n        help: false,\n        quiet: false,\n        dropHeaders: false,\n        exeSnippets: [],\n        vmExeSnippets: [],\n        condSnippets: [],\n        vmCondSnippets: [],\n        outputMode: OM_JSONY,\n        jsonIndent: 2,\n        array: null,\n        delim: ' ',\n        lookupDelim: '.',\n        outputKeys: false,\n        group: false,\n        merge: null, // --merge -> 'shallow', --deep-merge -> 'deep'\n        inputFiles: [],\n        validate: false,\n        inPlace: false\n    };\n\n    // Turn '-iH' into '-i -H', except for argument-accepting options.\n    var args = argv.slice(2); // drop ['node', 'scriptname']\n    var newArgs = [];\n    var optTakesArg = {\n        'd': true,\n        'o': true,\n        'D': true\n    };\n    for (var i = 0; i < args.length; i++) {\n        if (args[i] === '--') {\n            newArgs = newArgs.concat(args.slice(i));\n            break;\n        }\n        if (args[i].charAt(0) === '-' && args[i].charAt(1) !== '-' &&\n            args[i].length > 2)\n        {\n            var splitOpts = args[i].slice(1).split('');\n            for (var j = 0; j < splitOpts.length; j++) {\n                newArgs.push('-' + splitOpts[j])\n                if (optTakesArg[splitOpts[j]]) {\n                    var optArg = splitOpts.slice(j + 1).join('');\n                    if (optArg.length) {\n                        newArgs.push(optArg);\n                    }\n                    break;\n                }\n            }\n        } else {\n            newArgs.push(args[i]);\n        }\n    }\n    args = newArgs;\n\n    endOfOptions = false;\n    while (args.length > 0) {\n        var arg = args.shift();\n        switch (arg) {\n        case '--':\n            endOfOptions = true;\n            break;\n        case '-h': // display help and exit\n        case '--help':\n            parsed.help = true;\n            break;\n        case '--version':\n            parsed.version = true;\n            break;\n        case '-q':\n        case '--quiet':\n            parsed.quiet = true;\n            break;\n        case '-H': // drop any headers\n            parsed.dropHeaders = true;\n            break;\n        case '-o':\n        case '--output':\n            var name = args.shift();\n            if (!name) {\n                throw new Error('no argument given for \"-o|--output\" option');\n            }\n            var idx = name.lastIndexOf('-');\n            if (idx !== -1) {\n                var indent = Number(name.slice(idx + 1));\n                if (!isNaN(indent)) {\n                    parsed.jsonIndent = indent;\n                    name = name.slice(0, idx);\n                }\n            }\n            parsed.outputMode = OM_FROM_NAME[name];\n            if (parsed.outputMode === undefined) {\n                throw new Error('unknown output mode: \"' + name + '\"');\n            }\n            break;\n        case '-I':\n        case '--in-place':\n            parsed.inPlace = true;\n            break;\n        case '-i': // output with util.inspect\n            parsed.outputMode = OM_INSPECT;\n            break;\n        case '-j': // output with JSON.stringify\n            parsed.outputMode = OM_JSON;\n            break;\n        case '-a':\n        case '--array':\n            parsed.array = true;\n            break;\n        case '-A':\n            parsed.array = false;\n            break;\n        case '-d':\n            parsed.delim = _parseString(args.shift());\n            break;\n        case '-D':\n            parsed.lookupDelim = args.shift();\n            if (parsed.lookupDelim.length !== 1) {\n                throw new Error(format(\n                    'invalid lookup delim \"%s\" (must be a single char)',\n                    parsed.lookupDelim));\n            }\n            break;\n        case '-e':\n            parsed.vmExeSnippets.push(args.shift());\n            break;\n        case '-E':\n            parsed.exeSnippets.push(args.shift());\n            break;\n        case '-c':\n            parsed.vmCondSnippets.push(args.shift());\n            break;\n        case '-C':\n            parsed.condSnippets.push(args.shift());\n            break;\n        case '-k':\n        case '--keys':\n            parsed.outputKeys = true;\n            break;\n        case '-g':\n        case '--group':\n            parsed.group = true;\n            break;\n        case '--merge':\n            parsed.merge = 'shallow';\n            break;\n        case '--deep-merge':\n            parsed.merge = 'deep';\n            break;\n        case '-f':\n            parsed.inputFiles.push(args.shift());\n            break;\n        case '-n':\n        case '--validate':\n            parsed.validate = true;\n            break;\n        default: // arguments\n            if (!endOfOptions && arg.length > 0 && arg[0] === '-') {\n                throw new Error('unknown option \"' + arg + '\"');\n            }\n            parsed.args.push(arg);\n            break;\n        }\n    }\n\n    if (parsed.group && parsed.merge) {\n        throw new Error('cannot use -g|--group and --merge options together');\n    }\n    if (parsed.outputKeys && parsed.args.length > 0) {\n        throw new Error(\n            'cannot use -k|--keys option and lookup arguments together');\n    }\n    if (parsed.inPlace && parsed.inputFiles.length !== 1) {\n        throw new Error('must specify exactly one file with \"-f FILE\" to ' +\n            'use -I/--in-place');\n    }\n    if (parsed.inPlace && parsed.args.length > 0) {\n        throw new Error('lookups cannot be specified with in-place editing ' +\n            '(-I/--in-place), too easy to lose content');\n    }\n\n    return parsed;\n}\n\n\n\n/**\n * Streams chunks from given file paths or stdin.\n *\n * @param opts {Object} Parsed options.\n * @returns {Object} An emitter that emits 'chunk', 'error', and 'end'.\n *    - `emit('chunk', chunk, [obj])` where chunk is a complete block of JSON\n *       ready to parse. If `obj` is provided, it is the already parsed\n *       JSON.\n *    - `emit('error', error)` when an underlying stream emits an error\n *    - `emit('end')` when all streams are done\n */\nfunction chunkEmitter(opts) {\n    var emitter = new EventEmitter();\n    var streaming = true;\n    var chunks = [];\n    var leftover = '';\n    var finishedHeaders = false;\n\n    function stripHeaders(s) {\n        // Take off a leading HTTP header if any and pass it through.\n        while (true) {\n            if (s.slice(0, 5) === 'HTTP/') {\n                var index = s.indexOf('\\r\\n\\r\\n');\n                var sepLen = 4;\n                if (index == -1) {\n                    index = s.indexOf('\\n\\n');\n                    sepLen = 2;\n                }\n                if (index != -1) {\n                    if (!opts.dropHeaders) {\n                        emit(s.slice(0, index + sepLen));\n                    }\n                    var is100Continue = (\n                        s.slice(0, 21) === 'HTTP/1.1 100 Continue');\n                    s = s.slice(index + sepLen);\n                    if (is100Continue) {\n                        continue;\n                    }\n                    finishedHeaders = true;\n                }\n            } else {\n                finishedHeaders = true;\n            }\n            break;\n        }\n        //console.warn('stripHeaders done, finishedHeaders=%s', finishedHeaders)\n        return s;\n    }\n\n    function emitChunks(block, emitter) {\n        //console.warn('emitChunks start: block=\"%s\"', block)\n        /* JSSTYLED */\n        var splitter = /(})(\\s*\\n\\s*)?({\\s*\")/;\n        var leftTrimmedBlock = block.trimLeft();\n        if (leftTrimmedBlock && leftTrimmedBlock[0] !== '{') {\n            // Currently only support streaming consecutive *objects*.\n            streaming = false;\n            chunks.push(block);\n            return '';\n        }\n        /**\n         * Example:\n         * > '{\"a\":\"b\"}\\n{\"a\":\"b\"}\\n{\"a\":\"b\"}'.split(/(})(\\s*\\n\\s*)?({\\s*\")/)\n         * [ '{\"a\":\"b\"',\n         *   '}',\n         *   '\\n',\n         *   '{\"',\n         *   'a\":\"b\"',\n         *   '}',\n         *   '\\n',\n         *   '{\"',\n         *   'a\":\"b\"}' ]\n         */\n        var bits = block.split(splitter);\n        //console.warn('emitChunks: bits (length %d): %j', bits.length, bits);\n        if (bits.length === 1) {\n            /*\n             * An unwanted side-effect of using a regex to find\n             * newline-separated objects *with a regex*, is that we are looking\n             * for the end of one object leading into the start of a another.\n             * That means that we can end up buffering a complete object until\n             * a subsequent one comes in. If the input stream has large delays\n             * between objects, then this is unwanted buffering.\n             *\n             * One solution would be full stream parsing of objects a la\n             * <https://github.com/creationix/jsonparse>. This would nicely\n             * also remove the artibrary requirement that the input stream be\n             * newline separated. jsonparse apparently has some issues tho, so\n             * I don't want to use it right now. It also isn't *small* so not\n             * sure I want to inline it (`json` doesn't have external deps).\n             *\n             * An alternative: The block we have so far one of:\n             * 1. some JSON that we don't support grouping (e.g. a stream of\n             *    non-objects),\n             * 2. a JSON object fragment, or\n             * 3. a complete JSON object (with a possible trailing '{')\n             *\n             * If #3, then we can just emit this as a chunk right now.\n             *\n             * TODO(PERF): Try out avoiding the first more complete regex split\n             * for a presumed common case of single-line newline-separated JSON\n             * objects (e.g. a bunyan log).\n             */\n            // An object must end with '}'. This is an early out to avoid\n            // `JSON.parse` which I'm *presuming* is slower.\n            var trimmed = block.split(/\\s*\\r?\\n/)[0];\n            if (trimmed[trimmed.length - 1] === '}') {\n                var obj;\n                try {\n                    obj = JSON.parse(block);\n                } catch (e) {\n                    /* pass through */\n                }\n                if (obj !== undefined) {\n                    // Emit the parsed `obj` to avoid re-parsing it later.\n                    emitter.emit('chunk', block, obj);\n                    block = '';\n                }\n            }\n            return block;\n        } else {\n            var n = bits.length - 2;\n            var s;\n            s = bits[0] + bits[1];\n            emitter.emit('chunk', s, JSON.parse(s));\n            for (var i = 3; i < n; i += 4) {\n                s = bits[i] + bits[i + 1] + bits[i + 2];\n                emitter.emit('chunk', s, JSON.parse(s));\n            }\n            return bits[n] + bits[n + 1];\n        }\n    }\n\n    function addDataListener(stream) {\n        stream.on('data', function (chunk) {\n            var s = leftover + chunk;\n            if (!finishedHeaders) {\n                s = stripHeaders(s);\n            }\n            if (!finishedHeaders) {\n                leftover = s;\n            } else {\n                if (!streaming) {\n                    chunks.push(chunk);\n                    return;\n                }\n                leftover = emitChunks(s, emitter);\n            }\n        });\n    }\n\n    if (opts.inputFiles.length > 0) {\n        // Stream each file in order.\n        var i = 0;\n\n        function addErrorListener(file) {\n            file.on('error', function (err) {\n                emitter.emit(\n                    'error',\n                    format('could not read \"%s\": %s', opts.inputFiles[i], e)\n                );\n            });\n        }\n\n        function addEndListener(file) {\n            file.on('end', function () {\n                if (i < opts.inputFiles.length) {\n                    var next = opts.inputFiles[i++];\n                    var nextFile = fs.createReadStream(next,\n                        {encoding: 'utf8'});\n                    addErrorListener(nextFile);\n                    addEndListener(nextFile);\n                    addDataListener(nextFile);\n                } else {\n                    if (!streaming) {\n                        emitter.emit('chunk', chunks.join(''));\n                    } else if (leftover) {\n                        leftover = emitChunks(leftover, emitter);\n                        emitter.emit('chunk', leftover);\n                    }\n                    emitter.emit('end');\n                }\n            });\n        }\n        var first = fs.createReadStream(opts.inputFiles[i++],\n            {encoding: 'utf8'});\n        addErrorListener(first);\n        addEndListener(first);\n        addDataListener(first);\n    } else {\n        // Streaming from stdin.\n        var stdin = process.openStdin();\n        stdin.setEncoding('utf8');\n        addDataListener(stdin);\n        stdin.on('end', function () {\n            if (!streaming) {\n                emitter.emit('chunk', chunks.join(''));\n            } else if (leftover) {\n                leftover = emitChunks(leftover, emitter);\n                emitter.emit('chunk', leftover);\n            }\n            emitter.emit('end');\n        });\n    }\n    return emitter;\n}\n\n/**\n * Get input from either given file paths or stdin. If `opts.inPlace` then\n * this calls the callback once for each `opts.inputFiles`.\n *\n * @param opts {Object} Parsed options.\n * @param callback {Function} `function (err, content, filename)` where err\n *    is an error string if there was a problem, `content` is the read\n *    content and `filename` is the associated file name from which content\n *    was loaded if applicable.\n */\nfunction getInput(opts, callback) {\n    if (opts.inputFiles.length === 0) {\n        // Read from stdin.\n        var chunks = [];\n\n        var stdin = process.openStdin();\n        stdin.setEncoding('utf8');\n        stdin.on('data', function (chunk) {\n            chunks.push(chunk);\n        });\n\n        stdin.on('end', function () {\n            callback(null, chunks.join(''));\n        });\n    } else if (opts.inPlace) {\n        for (var i = 0; i < opts.inputFiles.length; i++) {\n            var file = opts.inputFiles[i];\n            var content;\n            try {\n                content = fs.readFileSync(file, 'utf8');\n            } catch (e) {\n                callback(e, null, file);\n            }\n            if (content) {\n                callback(null, content, file);\n            }\n        }\n    } else {\n        // Read input files.\n        var i = 0;\n        var chunks = [];\n        try {\n            for (; i < opts.inputFiles.length; i++) {\n                chunks.push(fs.readFileSync(opts.inputFiles[i], 'utf8'));\n            }\n        } catch (e) {\n            return callback(\n                format('could not read \"%s\": %s', opts.inputFiles[i], e));\n        }\n        callback(null, chunks.join(''),\n            (opts.inputFiles.length === 1 ? opts.inputFiles[0] : undefined));\n    }\n}\n\n\nfunction isInteger(s) {\n    return (s.search(/^-?[0-9]+$/) == 0);\n}\n\n\n/**\n * Parse a lookup string into a list of lookup bits. E.g.:\n *\n *    'a.b.c' -> [\"a\",\"b\",\"c\"]\n *    'b[\"a\"]' -> [\"b\",\"a\"]\n *    'b[\"a\" + \"c\"]' -> [\"b\",\"ac\"]\n *\n * Optionally receives an alternative lookup delimiter (other than '.')\n */\nfunction parseLookup(lookup, lookupDelim) {\n    var debug = function () {};\n    //var debug = console.warn;\n\n    var bits = [];\n    debug('\\n*** ' + lookup + ' ***');\n\n    bits = [];\n    lookupDelim = lookupDelim || '.';\n    var bit = '';\n    var states = [null];\n    var escaped = false;\n    var ch = null;\n    for (var i = 0; i < lookup.length; ++i) {\n        var escaped = (!escaped && ch === '\\\\');\n        var ch = lookup[i];\n        debug('-- i=' + i + ', ch=' + JSON.stringify(ch) + ' escaped=' +\n            JSON.stringify(escaped));\n        debug('states: ' + JSON.stringify(states));\n\n        if (escaped) {\n            bit += ch;\n            continue;\n        }\n\n        switch (states[states.length - 1]) {\n        case null:\n            switch (ch) {\n            case '\"':\n            case '\\'':\n                states.push(ch);\n                bit += ch;\n                break;\n            case '[':\n                states.push(ch);\n                if (bit !== '') {\n                    bits.push(bit);\n                    bit = ''\n                }\n                bit += ch;\n                break;\n            case lookupDelim:\n                if (bit !== '') {\n                    bits.push(bit);\n                    bit = ''\n                }\n                break;\n            default:\n                bit += ch;\n                break;\n            }\n            break;\n\n        case '[':\n            bit += ch;\n            switch (ch) {\n            case '\"':\n            case '\\'':\n            case '[':\n                states.push(ch);\n                break;\n            case ']':\n                states.pop();\n                if (states[states.length - 1] === null) {\n                    var evaled = vm.runInNewContext(\n                        '(' + bit.slice(1, -1) + ')', {}, '<lookup>');\n                    bits.push(evaled);\n                    bit = ''\n                }\n                break;\n            }\n            break;\n\n        case '\"':\n            bit += ch;\n            switch (ch) {\n            case '\"':\n                states.pop();\n                if (states[states.length - 1] === null) {\n                    bits.push(bit);\n                    bit = ''\n                }\n                break;\n            }\n            break;\n\n        case '\\'':\n            bit += ch;\n            switch (ch) {\n            case '\\'':\n                states.pop();\n                if (states[states.length - 1] === null) {\n                    bits.push(bit);\n                    bit = ''\n                }\n                break;\n            }\n            break;\n        }\n        debug('bit: ' + JSON.stringify(bit));\n        debug('bits: ' + JSON.stringify(bits));\n    }\n\n    if (bit !== '') {\n        bits.push(bit);\n        bit = ''\n    }\n\n    // Negative-intify: strings that are negative ints we change to a Number for\n    // special handling in `lookupDatum`: Python-style negative array indexing.\n    var negIntPat = /^-\\d+$/;\n    for (var i = 0; i < bits.length; i++) {\n        if (negIntPat.test(bits[i])) {\n            bits[i] = Number(bits[i]);\n        }\n    }\n\n    debug(JSON.stringify(lookup) + ' -> ' + JSON.stringify(bits));\n    return bits\n}\n\n\n/**\n * Parse the given stdin input into:\n *  {\n *    'error': ... error object if there was an error ...,\n *    'datum': ... parsed object if content was JSON ...\n *   }\n *\n * @param buffer {String} The text to parse as JSON.\n * @param obj {Object} Optional. Set when in streaming mode to avoid\n *    re-interpretation of `group`. Also avoids reparsing.\n * @param group {Boolean} Default false. If true, then non-JSON input\n *    will be attempted to be 'arrayified' (see inline comment).\n * @param merge {Boolean} Default null. Can be 'shallow' or 'deep'. An\n *    attempt will be made to interpret the input as adjacent objects to\n *    be merged, last key wins. See inline comment for limitations.\n */\nfunction parseInput(buffer, obj, group, merge) {\n    if (obj) {\n        return {\n            datum: obj\n        };\n    } else if (group) {\n        /**\n         * Special case: Grouping (previously called auto-arrayification)\n         * of unjoined list of objects:\n         *    {\"one\": 1}{\"two\": 2}\n         * and auto-concatenation of unjoined list of arrays:\n         *    [\"a\", \"b\"][\"c\", \"d\"]\n         *\n         * This can be nice to process a stream of JSON objects generated from\n         * multiple calls to another tool or `cat *.json | json`.\n         *\n         * Rules:\n         * - Only JS objects and arrays. Don't see strong need for basic\n         *   JS types right now and this limitation simplifies.\n         * - The break between JS objects has to include a newline:\n         *      {\"one\": 1}\n         *      {\"two\": 2}\n         *   or no spaces at all:\n         *      {\"one\": 1}{\"two\": 2}\n         *   I.e., not this:\n         *      {\"one\": 1}  {\"two\": 2}\n         *   This condition should be fine for typical use cases and ensures\n         *   no false matches inside JS strings.\n         * - The break between JS *arrays* has to include a newline:\n         *      [\"one\", \"two\"]\n         *      [\"three\"]\n         *   The 'no spaces' case is NOT supported for JS arrays as of v6.0.0\n         *   because <https://github.com/trentm/json/issues/55> shows that that\n         *   is not safe.\n         */\n        var newBuffer = buffer;\n        /* JSSTYLED */\n        [/(})\\s*\\n\\s*({)/g, /(})({\")/g].forEach(function (pat) {\n            newBuffer = newBuffer.replace(pat, '$1,\\n$2');\n        });\n        [/(\\])\\s*\\n\\s*(\\[)/g].forEach(function (pat) {\n            newBuffer = newBuffer.replace(pat, ',\\n');\n        });\n        newBuffer = newBuffer.trim();\n        if (newBuffer[0] !== '[') {\n            newBuffer = '[\\n' + newBuffer;\n        }\n        if (newBuffer.slice(-1) !== ']') {\n            newBuffer = newBuffer + '\\n]\\n';\n        }\n        try {\n            return {\n                datum: JSON.parse(newBuffer)\n            };\n        } catch (e2) {\n            return {\n                error: e2\n            };\n        }\n    } else if (merge) {\n        // See the 'Rules' above for limitations on boundaries for 'adjacent'\n        // objects: KISS.\n        var newBuffer = buffer;\n        /* JSSTYLED */\n        [/(})\\s*\\n\\s*({)/g, /(})({\")/g].forEach(function (pat) {\n            newBuffer = newBuffer.replace(pat, '$1,\\n$2');\n        });\n        newBuffer = '[\\n' + newBuffer + '\\n]\\n';\n        var objs;\n        try {\n            objs = JSON.parse(newBuffer);\n        } catch (e) {\n            return {\n                error: e\n            };\n        }\n        var merged = objs[0];\n        if (merge === 'shallow') {\n            for (var i = 1; i < objs.length; i++) {\n                var obj = objs[i];\n                Object.keys(obj).forEach(function (k) {\n                    merged[k] = obj[k];\n                });\n            }\n        } else if (merge === 'deep') {\n            function deepExtend(a, b) {\n                Object.keys(b).forEach(function (k) {\n                    if (a[k] && b[k] &&\n                        toString.call(a[k]) === '[object Object]' &&\n                        toString.call(b[k]) === '[object Object]')\n                    {\n                        deepExtend(a[k], b[k])\n                    } else {\n                        a[k] = b[k];\n                    }\n                });\n            }\n            for (var i = 1; i < objs.length; i++) {\n                deepExtend(merged, objs[i]);\n            }\n        } else {\n            throw new Error(format('unknown value for \"merge\": \"%s\"', merge));\n        }\n        return {\n            datum: merged\n        };\n    } else {\n        try {\n            return {\n                datum: JSON.parse(buffer)\n            };\n        } catch (e) {\n            return {\n                error: e\n            };\n        }\n    }\n}\n\n\n/**\n * Apply a lookup to the given datum.\n *\n * @argument datum {Object}\n * @argument lookup {Array} The parsed lookup (from\n *    `parseLookup(<string>, <string>)`). Might be empty.\n * @returns {Object} The result of the lookup.\n */\nfunction lookupDatum(datum, lookup) {\n    var d = datum;\n    for (var i = 0; i < lookup.length; i++) {\n        var bit = lookup[i];\n        if (typeof (bit) === 'number' && bit < 0) {\n            d = d[d.length + bit];\n        } else {\n            d = d[bit];\n        }\n        if (d === undefined) {\n            return undefined;\n        }\n    }\n    return d;\n}\n\n\n/**\n * Output the given datasets.\n *\n * @param datasets {Array} Array of data sets to print, in the form:\n *    `[ [<datum>, <sep>, <alwaysPrintSep>], ... ]`\n * @param filename {String} The filename to which to write the output. If\n *    not set, then emit to stdout.\n * @param headers {String} The HTTP header block string, if any, to emit\n *    first.\n * @param opts {Object} Parsed tool options.\n */\nfunction printDatasets(datasets, filename, headers, opts) {\n    var isTTY = (filename ? false : process.stdout.isTTY)\n    var write = emit;\n    if (filename) {\n        var tmpPath = path.resolve(path.dirname(filename),\n            format('.%s-json-%s-%s.tmp', path.basename(filename), process.pid,\n                Date.now()));\n        var stats = fs.statSync(filename);\n        var f = fs.createWriteStream(tmpPath,\n            {encoding: 'utf8', mode: stats.mode});\n        write = f.write.bind(f);\n    }\n    if (headers && headers.length > 0) {\n        write(headers)\n    }\n    for (var i = 0; i < datasets.length; i++) {\n        var dataset = datasets[i];\n        var output = stringifyDatum(dataset[0], opts, isTTY);\n        var sep = dataset[1];\n        if (output && output.length) {\n            write(output);\n            write(sep);\n        } else if (dataset[2]) {\n            write(sep);\n        }\n    }\n    if (filename) {\n        f.end();\n        fs.renameSync(tmpPath, filename);\n        if (!opts.quiet) {\n            warn('json: updated \"%s\" in-place', filename);\n        }\n    }\n}\n\n\n/**\n * Stringify the given datum according to the given output options.\n */\nfunction stringifyDatum(datum, opts, isTTY) {\n    var output = null;\n    switch (opts.outputMode) {\n    case OM_INSPECT:\n        output = util.inspect(datum, false, Infinity, isTTY);\n        break;\n    case OM_JSON:\n        if (typeof (datum) !== 'undefined') {\n            output = JSON.stringify(datum, null, opts.jsonIndent);\n        }\n        break;\n    case OM_COMPACT:\n        // Dev Note: A still relatively experimental attempt at a more\n        // compact ouput somewhat a la Python's repr of a dict. I.e. try to\n        // fit elements on one line as much as reasonable.\n        if (datum === undefined) {\n            // pass\n        } else if (Array.isArray(datum)) {\n            var bits = ['[\\n'];\n            datum.forEach(function (d) {\n                bits.push('  ')\n                bits.push(JSON.stringify(d, null, 0).replace(\n                    /* JSSTYLED */\n                    /,\"(?![,:])/g, ', \"'));\n                bits.push(',\\n');\n            });\n            bits.push(bits.pop().slice(0, -2) + '\\n') // drop last comma\n            bits.push(']');\n            output = bits.join('');\n        } else {\n            output = JSON.stringify(datum, null, 0);\n        }\n        break;\n    case OM_JSONY:\n        if (typeof (datum) === 'string') {\n            output = datum;\n        } else if (typeof (datum) !== 'undefined') {\n            output = JSON.stringify(datum, null, opts.jsonIndent);\n        }\n        break;\n    default:\n        throw new Error('unknown output mode: ' + opts.outputMode);\n    }\n    return output;\n}\n\n\n/**\n * Print out a single result, considering input options.\n *\n * @deprecated\n */\nfunction printDatum(datum, opts, sep, alwaysPrintSep) {\n    var output = stringifyDatum(datum, opts);\n    if (output && output.length) {\n        emit(output);\n        emit(sep);\n    } else if (alwaysPrintSep) {\n        emit(sep);\n    }\n}\n\n\nvar stdoutFlushed = true;\nfunction emit(s) {\n    // TODO:PERF If this is try/catch is too slow (too granular): move up to\n    //    mainline and be sure to only catch this particular error.\n    try {\n        stdoutFlushed = process.stdout.write(s);\n    } catch (e) {\n        // Handle any exceptions in stdout writing in the 'error' event above.\n    }\n}\n\nprocess.stdout.on('error', function (err) {\n    if (err.code === 'EPIPE') {\n        // See <https://github.com/trentm/json/issues/9>.\n        drainStdoutAndExit(0);\n    } else {\n        warn(err)\n        drainStdoutAndExit(1);\n    }\n});\n\n\n/**\n * A hacked up version of 'process.exit' that will first drain stdout\n * before exiting. *WARNING: This doesn't stop event processing.* IOW,\n * callers have to be careful that code following this call isn't\n * accidentally executed.\n *\n * In node v0.6 \"process.stdout and process.stderr are blocking when they\n * refer to regular files or TTY file descriptors.\" However, this hack might\n * still be necessary in a shell pipeline.\n */\nfunction drainStdoutAndExit(code) {\n    process.stdout.on('drain', function () {\n        process.exit(code);\n    });\n    if (stdoutFlushed) {\n        process.exit(code);\n    }\n}\n\n\n/**\n * Return a function for the given JS code that returns.\n *\n * If no 'return' in the given javascript snippet, then assume we are a single\n * statement and wrap in 'return (...)'. This is for convenience for short\n * '-C ...' snippets.\n */\nfunction funcWithReturnFromSnippet(js) {\n    if (js.indexOf('return') === -1) {\n        if (js.substring(js.length - 1) === ';') {\n            js = js.substring(0, js.length - 1);\n        }\n        js = 'return (' + js + ')';\n    }\n    return (new Function(js));\n}\n\n\n\n//---- mainline\n\nfunction main(argv) {\n    var opts;\n    try {\n        opts = parseArgv(argv);\n    } catch (e) {\n        warn('json: error: %s', e.message)\n        return drainStdoutAndExit(1);\n    }\n    //warn(opts);\n    if (opts.help) {\n        printHelp();\n        return;\n    }\n    if (opts.version) {\n        if (opts.outputMode === OM_JSON) {\n            var v = {\n                version: getVersion(),\n                author: 'Trent Mick',\n                project: 'https://github.com/trentm/json'\n            };\n            console.log(JSON.stringify(v, null, opts.jsonIndent));\n        } else {\n            console.log('json ' + getVersion());\n            console.log('written by Trent Mick');\n            console.log('https://github.com/trentm/json');\n        }\n        return;\n    }\n    var lookupStrs = opts.args;\n\n    // Prepare condition and execution funcs (and vm scripts) for -C/-E (-c/-e).\n    var i;\n    var condFuncs = [];\n    for (i = 0; i < opts.condSnippets.length; i++) {\n        condFuncs[i] = funcWithReturnFromSnippet(opts.condSnippets[i]);\n    }\n    var condScripts = [];\n    for (i = 0; i < opts.vmCondSnippets.length; i++) {\n        condScripts[i] = vm.createScript(opts.vmCondSnippets[i]);\n    }\n    var cond = Boolean(condFuncs.length + condScripts.length);\n    var exeFuncs = [];\n    for (i = 0; i < opts.exeSnippets.length; i++) {\n        exeFuncs[i] = new Function(opts.exeSnippets[i]);\n    }\n    var exeScripts = [];\n    for (i = 0; i < opts.vmExeSnippets.length; i++) {\n        exeScripts[i] = vm.createScript(opts.vmExeSnippets[i]);\n    }\n    var exe = Boolean(exeFuncs.length + exeScripts.length);\n\n    var lookups = lookupStrs.map(function (lookup) {\n        return parseLookup(lookup, opts.lookupDelim);\n    });\n\n    if (opts.group && opts.array && opts.outputMode !== OM_JSON) {\n        // streaming\n        var chunker = chunkEmitter(opts);\n        chunker.on('error', function (error) {\n            warn('json: error: %s', err);\n            return drainStdoutAndExit(1);\n        });\n        chunker.on('chunk', parseChunk);\n    } else if (opts.inPlace) {\n        assert.equal(opts.inputFiles.length, 1,\n            'cannot handle more than one file with -I');\n        getInput(opts, function (err, content, filename) {\n            if (err) {\n                warn('json: error: %s', err)\n                return drainStdoutAndExit(1);\n            }\n\n            // Take off a leading HTTP header if any and pass it through.\n            var headers = [];\n            while (true) {\n                if (content.slice(0, 5) === 'HTTP/') {\n                    var index = content.indexOf('\\r\\n\\r\\n');\n                    var sepLen = 4;\n                    if (index == -1) {\n                        index = content.indexOf('\\n\\n');\n                        sepLen = 2;\n                    }\n                    if (index != -1) {\n                        if (!opts.dropHeaders) {\n                            headers.push(content.slice(0, index + sepLen));\n                        }\n                        var is100Continue = (\n                            content.slice(0, 21) === 'HTTP/1.1 100 Continue');\n                        content = content.slice(index + sepLen);\n                        if (is100Continue) {\n                            continue;\n                        }\n                    }\n                }\n                break;\n            }\n            parseChunk(content, undefined, filename, true, headers.join(''));\n        });\n    } else {\n        // not streaming\n        getInput(opts, function (err, buffer, filename) {\n            if (err) {\n                warn('json: error: %s', err)\n                return drainStdoutAndExit(1);\n            }\n            // Take off a leading HTTP header if any and pass it through.\n            while (true) {\n                if (buffer.slice(0, 5) === 'HTTP/') {\n                    var index = buffer.indexOf('\\r\\n\\r\\n');\n                    var sepLen = 4;\n                    if (index == -1) {\n                        index = buffer.indexOf('\\n\\n');\n                        sepLen = 2;\n                    }\n                    if (index != -1) {\n                        if (!opts.dropHeaders) {\n                            emit(buffer.slice(0, index + sepLen));\n                        }\n                        var is100Continue = (\n                            buffer.slice(0, 21) === 'HTTP/1.1 100 Continue');\n                        buffer = buffer.slice(index + sepLen);\n                        if (is100Continue) {\n                            continue;\n                        }\n                    }\n                }\n                break;\n            }\n            parseChunk(buffer, null, filename, false);\n        });\n    }\n\n    /**\n     * Parse a single chunk of JSON. This may be called more than once\n     * (when streaming or when operating on multiple files).\n     *\n     * @param chunk {String} The JSON-encoded string.\n     * @param obj {Object} Optional. For some code paths while streaming `obj`\n     *    will be provided. This is an already parsed JSON object.\n     * @param filename {String} Optional. The filename from which this content\n     *    came, if relevant.\n     * @param inPlace {Boolean} Optional. If true, then output will be written\n     *    to `filename`.\n     * @param headers {String} Optional. Leading HTTP headers, if any to emit.\n     */\n    function parseChunk(chunk, obj, filename, inPlace, headers) {\n        // Expect the chunk to be JSON.\n        if (!chunk.length) {\n            return;\n        }\n        // parseInput() -> {datum: <input object>, error: <error object>}\n        var input = parseInput(chunk, obj, opts.group, opts.merge);\n        if (input.error) {\n            // Doesn't look like JSON. Just print it out and move on.\n            if (!opts.quiet) {\n                // Use JSON-js' \"json_parse\" parser to get more detail on the\n                // syntax error.\n                var details = '';\n                var normBuffer = chunk.replace(/\\r\\n|\\n|\\r/, '\\n');\n                try {\n                    json_parse(normBuffer);\n                    details = input.error;\n                } catch (err) {\n                    // err.at has the position. Get line/column from that.\n                    var at = err.at - 1; // `err.at` looks to be 1-based.\n                    var lines = chunk.split('\\n');\n                    var line, col, pos = 0;\n                    for (line = 0; line < lines.length; line++) {\n                        pos += lines[line].length + 1;\n                        if (pos > at) {\n                            col = at - (pos - lines[line].length - 1);\n                            break;\n                        }\n                    }\n                    var spaces = '';\n                    for (var i = 0; i < col; i++) {\n                        spaces += '.';\n                    }\n                    details = err.message + ' at line ' + (line + 1) +\n                        ', column ' + (col + 1) + ':\\n        ' +\n                        lines[line] + '\\n        ' + spaces + '^';\n                }\n                warn('json: error: %s is not JSON: %s',\n                    filename ? '\"' + filename + '\"' : 'input', details);\n            }\n            if (!opts.validate) {\n                emit(chunk);\n                if (chunk.length && chunk[chunk.length - 1] !== '\\n') {\n                    emit('\\n');\n                }\n            }\n            return drainStdoutAndExit(1);\n        }\n        if (opts.validate) {\n            return drainStdoutAndExit(0);\n        }\n        var data = input.datum;\n\n        // Process: executions (-E/-e)\n        var i, j;\n        if (!exe) {\n            /* pass */\n        } else if (opts.array || (opts.array === null && Array.isArray(data))) {\n            var arrayified = false;\n            if (!Array.isArray(data)) {\n                arrayified = true;\n                data = [data];\n            }\n            for (i = 0; i < data.length; i++) {\n                var datum = data[i];\n                for (j = 0; j < exeFuncs.length; j++) {\n                    exeFuncs[j].call(datum);\n                }\n                for (j = 0; j < exeScripts.length; j++) {\n                    exeScripts[j].runInNewContext(datum);\n                }\n            }\n            if (arrayified) {\n                data = data[0];\n            }\n        } else {\n            for (j = 0; j < exeFuncs.length; j++) {\n                exeFuncs[j].call(data);\n            }\n            for (j = 0; j < exeScripts.length; j++) {\n                exeScripts[j].runInNewContext(data);\n            }\n        }\n\n        // Process: conditionals (-C/-c)\n        if (!cond) {\n            /* pass */\n        } else if (opts.array || (opts.array === null && Array.isArray(data))) {\n            var arrayified = false;\n            if (!Array.isArray(data)) {\n                arrayified = true;\n                data = [data];\n            }\n            var filtered = [];\n            for (i = 0; i < data.length; i++) {\n                var datum = data[i];\n                var datumCopy = objCopy(datum);\n                var keep = true;\n                // TODO(perf): Perhaps drop the 'datumCopy'? \"this is a gun\"\n                for (j = 0; j < condFuncs.length; j++) {\n                    if (!condFuncs[j].call(datumCopy)) {\n                        keep = false;\n                        break;\n                    }\n                }\n                if (keep) {\n                    for (j = 0; j < condScripts.length; j++) {\n                        if (!condScripts[j].runInNewContext(datumCopy)) {\n                            keep = false;\n                            break;\n                        }\n                    }\n                    if (keep) {\n                        filtered.push(datum);\n                    }\n                }\n            }\n            if (arrayified) {\n                data = (filtered.length ? filtered[0] : []);\n            } else {\n                data = filtered;\n            }\n        } else {\n            var keep = true;\n            var dataCopy = objCopy(data);\n            for (j = 0; j < condFuncs.length; j++) {\n                // TODO(perf): Perhaps drop the 'dataCopy'? \"this is a gun\"\n                if (!condFuncs[j].call(dataCopy)) {\n                    keep = false;\n                    break;\n                }\n            }\n            if (keep) {\n                for (j = 0; j < condScripts.length; j++) {\n                    if (!condScripts[j].runInNewContext(dataCopy)) {\n                        keep = false;\n                        break;\n                    }\n                }\n            }\n            if (!keep) {\n                data = undefined;\n            }\n        }\n\n        // Process: lookups\n        var lookupsAreIndeces = false;\n        if (lookups.length) {\n            if (opts.array) {\n                if (!Array.isArray(data)) data = [data];\n                var table = [];\n                for (j = 0; j < data.length; j++) {\n                    var datum = data[j];\n                    var row = {};\n                    for (i = 0; i < lookups.length; i++) {\n                        var lookup = lookups[i];\n                        var value = lookupDatum(datum, lookup);\n                        if (value !== undefined) {\n                            row[lookup.join('.')] = value;\n                        }\n                    }\n                    table.push(row);\n                }\n                data = table;\n            } else {\n                // Special case handling: Note if the 'lookups' are indeces into\n                // an array. This may be used below to change the output\n                // representation.\n                if (Array.isArray(data)) {\n                    lookupsAreIndeces = true;\n                    for (i = 0; i < lookups.length; i++) {\n                        if (lookups[i].length !== 1 ||\n                            isNaN(Number(lookups[i])))\n                        {\n                            lookupsAreIndeces = false;\n                            break;\n                        }\n                    }\n                }\n                var row = {};\n                for (i = 0; i < lookups.length; i++) {\n                    var lookup = lookups[i];\n                    var value = lookupDatum(data, lookup);\n                    if (value !== undefined) {\n                        row[lookup.join('.')] = value;\n                    }\n                }\n                data = row;\n            }\n        }\n\n        // --keys\n        if (opts.outputKeys) {\n            var data = Object.keys(data);\n        }\n\n        // Output\n        var datasets = [];\n        if (opts.outputMode === OM_JSON) {\n            if (lookups.length === 1 && !opts.array) {\n                /**\n                 * Special case: For JSON output of a *single* lookup, *don't*\n                 * use the full table structure, else there is no way to get\n                 * string quoting for a single value:\n                 *      $ echo '{\"a\": [], \"b\": \"[]\"}' | json -j a\n                 *      []\n                 *      $ echo '{\"a\": [], \"b\": \"[]\"}' | json -j b\n                 *      '[]'\n                 * See <https://github.com/trentm/json/issues/35> for why.\n                 */\n                data = data[lookups[0].join('.')];\n            } else if (lookupsAreIndeces) {\n                /**\n                 * Special case: Lookups that are all indeces into an input\n                 * array are more likely to be wanted as an array of selected\n                 * items rather than a 'JSON table' thing that we use otherwise.\n                 */\n                var flattened = [];\n                for (i = 0; i < lookups.length; i++) {\n                    var lookupStr = lookups[i].join('.');\n                    if (data.hasOwnProperty(lookupStr)) {\n                        flattened.push(data[lookupStr])\n                    }\n                }\n                data = flattened;\n            }\n            // If JSON output mode, then always just output full set of data to\n            // ensure valid JSON output.\n            datasets.push([data, '\\n', false]);\n        } else if (lookups.length) {\n            if (opts.array) {\n                // Output `data` as a 'table' of lookup results.\n                for (j = 0; j < data.length; j++) {\n                    var row = data[j];\n                    for (i = 0; i < lookups.length - 1; i++) {\n                        datasets.push([row[lookups[i].join('.')],\n                            opts.delim, true]);\n                    }\n                    datasets.push([row[lookups[i].join('.')], '\\n', true]);\n                }\n            } else {\n                for (i = 0; i < lookups.length; i++) {\n                    datasets.push([data[lookups[i].join('.')], '\\n', false]);\n                }\n            }\n        } else if (opts.array) {\n            if (!Array.isArray(data)) data = [data];\n            for (j = 0; j < data.length; j++) {\n                datasets.push([data[j], '\\n', false]);\n            }\n        } else {\n            // Output `data` as is.\n            datasets.push([data, '\\n', false]);\n        }\n        printDatasets(datasets, inPlace ? filename : undefined, headers, opts);\n    }\n}\n\nif (require.main === module) {\n    // HACK guard for <https://github.com/trentm/json/issues/24>.\n    // We override the `process.stdout.end` guard that core node.js puts in\n    // place. The real fix is that `.end()` shouldn't be called on stdout\n    // in node core. Hopefully node v0.6.9 will fix that. Only guard\n    // for v0.6.0..v0.6.8.\n    var nodeVer = process.versions.node.split('.').map(Number);\n    if ([0, 6, 0] <= nodeVer && nodeVer <= [0, 6, 8]) {\n        var stdout = process.stdout;\n        stdout.end = stdout.destroy = stdout.destroySoon = function () {\n            /* pass */\n        };\n    }\n\n    main(process.argv);\n}\n"}